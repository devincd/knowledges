## 32-浅谈容器网络

在前面讲解容器基础时，我曾经提到过一个 Linux 容器能看见的"网络栈"，实际上是被隔离在它自己的 
Network Namespace 当中的。

而所谓"网络栈"，就包括：网卡（Network Interface）、回环设备（Loopback Device），路由表（Routing Table）
和 iptables 规则。对于一个进程来说，这些要素，其实就构成了它发起和响应网络请求的基本环境。

需要指出的是， 作为一个容器，它可以声明直接使用宿主机的网络栈（--net=host），即：不开启 Network Namespace，比如：
```shell
$ docker run -d -net=host --name nginx-host nginx
```
在这种情况下，这个容器启动后，直接监听的就是宿主机的80端口。

像这样直接使用宿主机网络栈的方式，虽然可以为容器提供良好的网络性能，但也会不可避免地引入共享网络资源的问题，
比如端口冲突。所以，在大多数情况下，我们都希望容器进程能使用自己 Network Namespace 里的网络栈，即：拥有属于自己的 IP 地址和端口。

这时候，一个显而易见的问题就是：这个被隔离的容器进程，该如何跟其他 Network Namespace 里的容器进程进行交互呢？

为了理解这个问题，其实可以把每一个容器看做一台主机，它们都有一套独立的"网络栈"。

如果你想实现两台主机之间的通信，最直接的办法，就是把它们用一根网线连接起来；而如果你想要实现多台主机之间的通信，那就需要网线，把它们连接在一台交换机上。

在 Linux 中，能够起到虚拟交换机作用的网络设备，是网桥（Bridge）。它是一个工作在数据链路层（Data Link）的设备，
主要功能是根据 MAC 地址学习来将数据包转发到网桥的不同端口（Port）上。

当然，至于为什么这些主机之间需要 MAC 地址才能进行通信，这就是网络分层模型的基础知识了。

而为了实现上述目的，Docker 项目会默认在宿主机上创建一个名叫 docker0 的网桥，凡是连接在 docker0 网桥上的容器，
就可以通过它来进行通信。

可是，我们又该如何把这些容器"连接"到 docker0 网桥上呢？

这时候，我们就需要使用一种名叫 Veth Pair 的虚拟设备了。

Veth Pair 设备的特点是：它被创建出来后，总是以两张虚拟网卡（Veth Peer）的形式成对出现的。
并且从其中一个"网卡"发出的数据包，可以直接出现在它对应的另一张"网卡"上，哪怕这两个"网卡"在不同的
Network Namespace 里。

这就使得 Veth Pair 常常被用作连接不同 Network Namespace 的 "网线"。


